// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Blockchain.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum CitaProofType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authorityRound // = 0
  case raft // = 1
  case bft // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .authorityRound
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authorityRound
    case 1: self = .raft
    case 2: self = .bft
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authorityRound: return 0
    case .raft: return 1
    case .bft: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CitaProofType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CitaProofType] = [
    .authorityRound,
    .raft,
    .bft,
  ]
}

#endif  // swift(>=4.2)

enum CitaCrypto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case `default` // = 0
  case reserved // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .reserved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .reserved: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CitaCrypto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CitaCrypto] = [
    .default,
    .reserved,
  ]
}

#endif  // swift(>=4.2)

struct CitaProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = SwiftProtobuf.Internal.emptyData

  var type: CitaProofType = .authorityRound

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaBlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prevhash: Data {
    get {return _storage._prevhash}
    set {_uniqueStorage()._prevhash = newValue}
  }

  var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  var stateRoot: Data {
    get {return _storage._stateRoot}
    set {_uniqueStorage()._stateRoot = newValue}
  }

  var transactionsRoot: Data {
    get {return _storage._transactionsRoot}
    set {_uniqueStorage()._transactionsRoot = newValue}
  }

  var receiptsRoot: Data {
    get {return _storage._receiptsRoot}
    set {_uniqueStorage()._receiptsRoot = newValue}
  }

  var quotaUsed: UInt64 {
    get {return _storage._quotaUsed}
    set {_uniqueStorage()._quotaUsed = newValue}
  }

  var quotaLimit: UInt64 {
    get {return _storage._quotaLimit}
    set {_uniqueStorage()._quotaLimit = newValue}
  }

  var proof: CitaProof {
    get {return _storage._proof ?? CitaProof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {_uniqueStorage()._proof = nil}

  var proposer: Data {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Data = SwiftProtobuf.Internal.emptyData

  var height: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaAccountGasLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commonQuotaLimit: UInt64 = 0

  var specificQuotaLimit: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaRichStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Data = SwiftProtobuf.Internal.emptyData

  var height: UInt64 = 0

  var nodes: [Data] = []

  var interval: UInt64 = 0

  var version: UInt32 = 0

  var validators: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var to: String = String()

  var nonce: String = String()

  var quota: UInt64 = 0

  var validUntilBlock: UInt64 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var value: Data = SwiftProtobuf.Internal.emptyData

  var chainID: UInt32 = 0

  var version: UInt32 = 0

  var toV1: Data = SwiftProtobuf.Internal.emptyData

  var chainIDV1: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaUnverifiedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: CitaTransaction {
    get {return _storage._transaction ?? CitaTransaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var crypto: CitaCrypto {
    get {return _storage._crypto}
    set {_uniqueStorage()._crypto = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaSignedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionWithSig: CitaUnverifiedTransaction {
    get {return _storage._transactionWithSig ?? CitaUnverifiedTransaction()}
    set {_uniqueStorage()._transactionWithSig = newValue}
  }
  /// Returns true if `transactionWithSig` has been explicitly set.
  var hasTransactionWithSig: Bool {return _storage._transactionWithSig != nil}
  /// Clears the value of `transactionWithSig`. Subsequent reads from it will return its default value.
  mutating func clearTransactionWithSig() {_uniqueStorage()._transactionWithSig = nil}

  /// SignedTransaction hash
  var txHash: Data {
    get {return _storage._txHash}
    set {_uniqueStorage()._txHash = newValue}
  }

  /// public key
  var signer: Data {
    get {return _storage._signer}
    set {_uniqueStorage()._signer = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaBlockBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [CitaSignedTransaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaCompactBlockBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txHashes: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CitaBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var header: CitaBlockHeader {
    get {return _storage._header ?? CitaBlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var body: CitaBlockBody {
    get {return _storage._body ?? CitaBlockBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaCompactBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var header: CitaBlockHeader {
    get {return _storage._header ?? CitaBlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var body: CitaCompactBlockBody {
    get {return _storage._body ?? CitaCompactBlockBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaBlockWithProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blk: CitaBlock {
    get {return _storage._blk ?? CitaBlock()}
    set {_uniqueStorage()._blk = newValue}
  }
  /// Returns true if `blk` has been explicitly set.
  var hasBlk: Bool {return _storage._blk != nil}
  /// Clears the value of `blk`. Subsequent reads from it will return its default value.
  mutating func clearBlk() {_uniqueStorage()._blk = nil}

  var proof: CitaProof {
    get {return _storage._proof ?? CitaProof()}
    set {_uniqueStorage()._proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return _storage._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {_uniqueStorage()._proof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaBlockTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  var body: CitaBlockBody {
    get {return _storage._body ?? CitaBlockBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CitaBlackList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// black list of address, the account that sent the transaction does not have enough gas
  var blackList: [Data] = []

  /// clear list of address
  var clearList_p: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// State positioning signal
struct CitaStateSignal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension CitaProofType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AuthorityRound"),
    1: .same(proto: "Raft"),
    2: .same(proto: "Bft"),
  ]
}

extension CitaCrypto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "RESERVED"),
  ]
}

extension CitaProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Proof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.content)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    if self.type != .authorityRound {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaProof, rhs: CitaProof) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prevhash"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "height"),
    4: .standard(proto: "state_root"),
    5: .standard(proto: "transactions_root"),
    6: .standard(proto: "receipts_root"),
    7: .standard(proto: "quota_used"),
    8: .standard(proto: "quota_limit"),
    9: .same(proto: "proof"),
    10: .same(proto: "proposer"),
  ]

  fileprivate class _StorageClass {
    var _prevhash: Data = SwiftProtobuf.Internal.emptyData
    var _timestamp: UInt64 = 0
    var _height: UInt64 = 0
    var _stateRoot: Data = SwiftProtobuf.Internal.emptyData
    var _transactionsRoot: Data = SwiftProtobuf.Internal.emptyData
    var _receiptsRoot: Data = SwiftProtobuf.Internal.emptyData
    var _quotaUsed: UInt64 = 0
    var _quotaLimit: UInt64 = 0
    var _proof: CitaProof? = nil
    var _proposer: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _prevhash = source._prevhash
      _timestamp = source._timestamp
      _height = source._height
      _stateRoot = source._stateRoot
      _transactionsRoot = source._transactionsRoot
      _receiptsRoot = source._receiptsRoot
      _quotaUsed = source._quotaUsed
      _quotaLimit = source._quotaLimit
      _proof = source._proof
      _proposer = source._proposer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._prevhash)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._timestamp)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._stateRoot)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._transactionsRoot)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._receiptsRoot)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._quotaUsed)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._quotaLimit)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._proof)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._proposer)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._prevhash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._prevhash, fieldNumber: 1)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 2)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 3)
      }
      if !_storage._stateRoot.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._stateRoot, fieldNumber: 4)
      }
      if !_storage._transactionsRoot.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._transactionsRoot, fieldNumber: 5)
      }
      if !_storage._receiptsRoot.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._receiptsRoot, fieldNumber: 6)
      }
      if _storage._quotaUsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._quotaUsed, fieldNumber: 7)
      }
      if _storage._quotaLimit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._quotaLimit, fieldNumber: 8)
      }
      if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposer, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlockHeader, rhs: CitaBlockHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._prevhash != rhs_storage._prevhash {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._stateRoot != rhs_storage._stateRoot {return false}
        if _storage._transactionsRoot != rhs_storage._transactionsRoot {return false}
        if _storage._receiptsRoot != rhs_storage._receiptsRoot {return false}
        if _storage._quotaUsed != rhs_storage._quotaUsed {return false}
        if _storage._quotaLimit != rhs_storage._quotaLimit {return false}
        if _storage._proof != rhs_storage._proof {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaStatus, rhs: CitaStatus) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaAccountGasLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccountGasLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_quota_limit"),
    2: .standard(proto: "specific_quota_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.commonQuotaLimit)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.specificQuotaLimit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commonQuotaLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.commonQuotaLimit, fieldNumber: 1)
    }
    if !self.specificQuotaLimit.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.specificQuotaLimit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaAccountGasLimit, rhs: CitaAccountGasLimit) -> Bool {
    if lhs.commonQuotaLimit != rhs.commonQuotaLimit {return false}
    if lhs.specificQuotaLimit != rhs.specificQuotaLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaRichStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RichStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "nodes"),
    4: .same(proto: "interval"),
    5: .same(proto: "version"),
    6: .same(proto: "validators"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.nodes)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.interval)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 6: try decoder.decodeRepeatedBytesField(value: &self.validators)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.nodes, fieldNumber: 3)
    }
    if self.interval != 0 {
      try visitor.visitSingularUInt64Field(value: self.interval, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 5)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.validators, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaRichStatus, rhs: CitaRichStatus) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.version != rhs.version {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "nonce"),
    3: .same(proto: "quota"),
    4: .standard(proto: "valid_until_block"),
    5: .same(proto: "data"),
    6: .same(proto: "value"),
    7: .standard(proto: "chain_id"),
    8: .same(proto: "version"),
    9: .standard(proto: "to_v1"),
    10: .standard(proto: "chain_id_v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.to)
      case 2: try decoder.decodeSingularStringField(value: &self.nonce)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.quota)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.validUntilBlock)
      case 5: try decoder.decodeSingularBytesField(value: &self.data)
      case 6: try decoder.decodeSingularBytesField(value: &self.value)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.chainID)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 9: try decoder.decodeSingularBytesField(value: &self.toV1)
      case 10: try decoder.decodeSingularBytesField(value: &self.chainIDV1)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 2)
    }
    if self.quota != 0 {
      try visitor.visitSingularUInt64Field(value: self.quota, fieldNumber: 3)
    }
    if self.validUntilBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.validUntilBlock, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 6)
    }
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 7)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 8)
    }
    if !self.toV1.isEmpty {
      try visitor.visitSingularBytesField(value: self.toV1, fieldNumber: 9)
    }
    if !self.chainIDV1.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainIDV1, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaTransaction, rhs: CitaTransaction) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.quota != rhs.quota {return false}
    if lhs.validUntilBlock != rhs.validUntilBlock {return false}
    if lhs.data != rhs.data {return false}
    if lhs.value != rhs.value {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.toV1 != rhs.toV1 {return false}
    if lhs.chainIDV1 != rhs.chainIDV1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaUnverifiedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnverifiedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "signature"),
    3: .same(proto: "crypto"),
  ]

  fileprivate class _StorageClass {
    var _transaction: CitaTransaction? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _crypto: CitaCrypto = .default

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _signature = source._signature
      _crypto = source._crypto
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._crypto)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
      if _storage._crypto != .default {
        try visitor.visitSingularEnumField(value: _storage._crypto, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaUnverifiedTransaction, rhs: CitaUnverifiedTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._crypto != rhs_storage._crypto {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaSignedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_with_sig"),
    2: .standard(proto: "tx_hash"),
    3: .same(proto: "signer"),
  ]

  fileprivate class _StorageClass {
    var _transactionWithSig: CitaUnverifiedTransaction? = nil
    var _txHash: Data = SwiftProtobuf.Internal.emptyData
    var _signer: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionWithSig = source._transactionWithSig
      _txHash = source._txHash
      _signer = source._signer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionWithSig)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._txHash)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signer)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionWithSig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._txHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._txHash, fieldNumber: 2)
      }
      if !_storage._signer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signer, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaSignedTransaction, rhs: CitaSignedTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionWithSig != rhs_storage._transactionWithSig {return false}
        if _storage._txHash != rhs_storage._txHash {return false}
        if _storage._signer != rhs_storage._signer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlockBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlockBody, rhs: CitaBlockBody) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaCompactBlockBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CompactBlockBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.txHashes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaCompactBlockBody, rhs: CitaCompactBlockBody) -> Bool {
    if lhs.txHashes != rhs.txHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "header"),
    3: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _header: CitaBlockHeader? = nil
    var _body: CitaBlockBody? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _header = source._header
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._body)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlock, rhs: CitaBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaCompactBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CompactBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "header"),
    3: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _header: CitaBlockHeader? = nil
    var _body: CitaCompactBlockBody? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _header = source._header
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._body)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaCompactBlock, rhs: CitaCompactBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlockWithProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockWithProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blk"),
    2: .same(proto: "proof"),
  ]

  fileprivate class _StorageClass {
    var _blk: CitaBlock? = nil
    var _proof: CitaProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _blk = source._blk
      _proof = source._proof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._blk)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._proof)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._blk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._proof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlockWithProof, rhs: CitaBlockWithProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blk != rhs_storage._blk {return false}
        if _storage._proof != rhs_storage._proof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlockTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockTxs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    3: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _body: CitaBlockBody? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._body)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlockTxs, rhs: CitaBlockTxs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaBlackList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlackList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "black_list"),
    2: .standard(proto: "clear_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.blackList)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.clearList_p)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blackList.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.blackList, fieldNumber: 1)
    }
    if !self.clearList_p.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.clearList_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaBlackList, rhs: CitaBlackList) -> Bool {
    if lhs.blackList != rhs.blackList {return false}
    if lhs.clearList_p != rhs.clearList_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CitaStateSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StateSignal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CitaStateSignal, rhs: CitaStateSignal) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
